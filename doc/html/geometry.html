<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<title>Geometry</title>
<link rel="stylesheet" href="default.css" type="text/css" />
</head>
<body>
<div class="document" id="geometry">
<h1 class="title">Geometry</h1>

<p><strong>Last modified</strong>: May 17, 2022</p>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#convex-hull-as-image" id="toc-entry-1"><tt class="docutils literal">convex_hull_as_image</tt></a></li>
<li><a class="reference internal" href="#convex-hull-as-points-1" id="toc-entry-2"><tt class="docutils literal">convex_hull_as_points</tt></a></li>
<li><a class="reference internal" href="#convex-hull-from-points" id="toc-entry-3"><tt class="docutils literal">convex_hull_from_points</tt></a></li>
<li><a class="reference internal" href="#delaunay-from-points" id="toc-entry-4"><tt class="docutils literal">delaunay_from_points</tt></a></li>
<li><a class="reference internal" href="#hough-lines" id="toc-entry-5"><tt class="docutils literal">hough_lines</tt></a></li>
<li><a class="reference internal" href="#labeled-region-neighbors" id="toc-entry-6"><tt class="docutils literal">labeled_region_neighbors</tt></a></li>
<li><a class="reference internal" href="#max-empty-rect" id="toc-entry-7"><tt class="docutils literal">max_empty_rect</tt></a></li>
<li><a class="reference internal" href="#voronoi-from-labeled-image" id="toc-entry-8"><tt class="docutils literal">voronoi_from_labeled_image</tt></a></li>
<li><a class="reference internal" href="#voronoi-from-points" id="toc-entry-9"><tt class="docutils literal">voronoi_from_points</tt></a></li>
</ul>
</div>
<div class="section" id="convex-hull-as-image">
<h1><a class="toc-backref" href="#toc-entry-1"><tt class="docutils literal">convex_hull_as_image</tt></a></h1>
<p><tt class="docutils literal">Image</tt> [OneBit] <strong>convex_hull_as_image</strong> (<tt class="docutils literal">bool</tt> <em>filled</em> = False)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Operates on:</th><td class="field-body"><tt class="docutils literal">Image</tt> [OneBit]</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal">Image</tt> [OneBit]</td>
</tr>
<tr class="field"><th class="field-name">Category:</th><td class="field-body">Geometry</td>
</tr>
<tr class="field"><th class="field-name">Defined in:</th><td class="field-body">geometry.py</td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Christoph Dalitz</td>
</tr>
</tbody>
</table>
<p>Returns an image containing the polygon of the convex hull calculated
by <a class="reference external" href="geometry.html#convex_hull_as_points">convex_hull_as_points</a>.</p>
<hr class="docutils" />
<p><strong>Example 1:</strong> convex_hull_as_image()</p>
<img alt="images/OneBit_generic.png" src="images/OneBit_generic.png" style="width: 69px; height: 99px;" />
<img alt="images/convex_hull_as_image_plugin_00.png" src="images/convex_hull_as_image_plugin_00.png" style="width: 69px; height: 99px;" />
</div>
<div class="section" id="convex-hull-as-points-1">
<h1><a class="toc-backref" href="#toc-entry-2"><tt class="docutils literal">convex_hull_as_points</tt></a></h1>
<p>[object] <strong>convex_hull_as_points</strong> ()</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Operates on:</th><td class="field-body"><tt class="docutils literal">Image</tt> [OneBit]</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">[object]</td>
</tr>
<tr class="field"><th class="field-name">Category:</th><td class="field-body">Geometry</td>
</tr>
<tr class="field"><th class="field-name">Defined in:</th><td class="field-body">geometry.py</td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Christoph Dalitz</td>
</tr>
</tbody>
</table>
<p>Returns the vertex points of the convex hull of all black pixels
in the given image.</p>
<p>Actually not all black pixels are required for computing the convex hull,
but only the left and right contour pixels of the image. This follows
from the fact that, when a point is invisible both from the left and the
right, it lies on the connection axis between two visible points and thus
cannot be a vertex point of the convex hull.</p>
</div>
<div class="section" id="convex-hull-from-points">
<h1><a class="toc-backref" href="#toc-entry-3"><tt class="docutils literal">convex_hull_from_points</tt></a></h1>
<p>[object] <strong>convex_hull_from_points</strong> ([object <em>points</em>])</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">[object]</td>
</tr>
<tr class="field"><th class="field-name">Category:</th><td class="field-body">Geometry</td>
</tr>
<tr class="field"><th class="field-name">Defined in:</th><td class="field-body">geometry.py</td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Christian Brandt, Christoph Dalitz, and David Kolanus</td>
</tr>
</tbody>
</table>
<p>Returns the polygon vertices of the convex hull of the given list of
points.</p>
<p>The function uses Graham's scan algorithm as described e.g. in Cormen et al.:
<em>Introduction to Algorithms.</em> 2nd ed., MIT Press, p. 949, 2001</p>
</div>
<div class="section" id="delaunay-from-points">
<h1><a class="toc-backref" href="#toc-entry-4"><tt class="docutils literal">delaunay_from_points</tt></a></h1>
<p>object <strong>delaunay_from_points</strong> ([object <em>points</em>], <tt class="docutils literal">IntVector</tt> <em>labels</em>)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">object</td>
</tr>
<tr class="field"><th class="field-name">Category:</th><td class="field-body">Geometry</td>
</tr>
<tr class="field"><th class="field-name">Defined in:</th><td class="field-body">geometry.py</td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Oliver Christen (based on code by Olivier Devillers)</td>
</tr>
</tbody>
</table>
<p>Computes the Delaunay triangulation directly from a list of points and
point labels. The result is a list which contains tuples of adjacent labels,
where in each tuple the smaller label is given first.</p>
<p>The arguments <em>points</em> and <em>labels</em> specify the points and nonnegative
labels, such that <tt class="docutils literal">labels[i]</tt> is the label of <tt class="docutils literal">points[i]</tt>. Note that
the labels need not necessarily all be different, which can be useful
for the computation of a neighborship graph from a set of connected
components.</p>
<p>The computation of the Delaunay triangulation is based on the Delaunay
tree which is a randomized geometric data structure. It is
described in O. Devillers, S. Meiser, M. Teillaud:
<a class="reference external" href="http://hal.inria.fr/inria-00090678">Fully dynamic Delaunay triangulation in logarithmic expected time per operation.</a>
Computational Geometry: Theory and Applications 2, pp. 55-80, 1992.</p>
<p>This can be useful for building a neighborhood graph as shown in the
following example:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">gamera</span> <span class="kn">import</span> <span class="n">graph</span>
<span class="kn">from</span> <span class="nn">gamera.plugins.geometry</span> <span class="kn">import</span> <span class="n">delaunay_from_points</span>

<span class="n">points</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">),(</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">),(</span><span class="mi">32</span><span class="p">,</span><span class="mi">22</span><span class="p">),(</span><span class="mi">85</span><span class="p">,</span><span class="mi">14</span><span class="p">),(</span><span class="mi">40</span><span class="p">,</span><span class="mi">70</span><span class="p">),(</span><span class="mi">80</span><span class="p">,</span><span class="mi">85</span><span class="p">)]</span>
<span class="n">labels</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">))</span>
<span class="n">neighbors</span> <span class="o">=</span> <span class="n">delaunay_from_points</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">UNDIRECTED</span><span class="p">)</span>
<span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
    <span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<div class="section" id="hough-lines">
<h1><a class="toc-backref" href="#toc-entry-5"><tt class="docutils literal">hough_lines</tt></a></h1>
<p>object <strong>hough_lines</strong> ([object <em>points</em>], float <em>theta_min</em>, float <em>theta_step</em>, float <em>theta_max</em>, float <em>rho_min</em>, float <em>rho_step</em>, float <em>rho_max</em>, int <em>n_lines</em>, float <em>threshold</em>)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">object</td>
</tr>
<tr class="field"><th class="field-name">Category:</th><td class="field-body">Geometry</td>
</tr>
<tr class="field"><th class="field-name">Defined in:</th><td class="field-body">geometry.py</td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Manuel Jeltsch and Christoph Dalitz</td>
</tr>
</tbody>
</table>
<p>Finds lines in a point set with the Hough transform. Lines are
represented by the Hessian normal form, i.e. by the two parameters
<em>theta</em> and <em>rho</em>, where <em>rho</em> is the distance of the line to the origin,
and <em>theta</em> is the angle of normal; a horizontal line therefore
has <em>theta</em> = 90 degrees.</p>
<p>The found lines are returned as a list of tuples
[(<em>votes</em>, <em>theta</em>, <em>rho</em>),...],
where <em>votes</em> is the number of points from the point set belonging to
this line. The lines are sorted by <em>votes</em> in descending order. Which and
how many lines are returned is controlled with <em>threshold</em> and <em>n_lines</em>.
The angles <em>theta</em> are given in degrees.</p>
<p>Arguments:</p>
<dl class="docutils">
<dt><em>points</em>:</dt>
<dd>The points from the point cloud.</dd>
<dt><em>theta_min</em>, <em>theta_step</em>, <em>theta_max</em></dt>
<dd>Theta-quantization of the Hough space, i.e. the range of angles
to be tested. Angles are spezified in degrees.</dd>
<dt><em>rho_min</em>, <em>rho_step</em>, <em>rho_max</em></dt>
<dd>Rho-quantization of the Hough space, i.e. the range of origin-distances
to be tested.</dd>
<dt><em>n_lines</em></dt>
<dd>The number of highest votes lines that are returned. When set to
zero, all found lines are returned.</dd>
<dt><em>threshold</em></dt>
<dd>Only lines with more votes (points) than <em>threshold</em> are returned.</dd>
</dl>
</div>
<div class="section" id="labeled-region-neighbors">
<h1><a class="toc-backref" href="#toc-entry-6"><tt class="docutils literal">labeled_region_neighbors</tt></a></h1>
<p>object <strong>labeled_region_neighbors</strong> (<tt class="docutils literal">bool</tt> <em>eight_connectivity</em> = True)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Operates on:</th><td class="field-body"><tt class="docutils literal">Image</tt> [OneBit]</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">object</td>
</tr>
<tr class="field"><th class="field-name">Category:</th><td class="field-body">Geometry</td>
</tr>
<tr class="field"><th class="field-name">Defined in:</th><td class="field-body">geometry.py</td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Christoph Dalitz</td>
</tr>
</tbody>
</table>
<p>For an image containing labeled regions, a list of all label pairs belonging
to touching regions is returned. When <em>eight_connectivity</em> is <tt class="docutils literal">True</tt>
(default), 8-connectivity is used for neighborship, otherwise
4-connectivity is used.</p>
<p>This can be useful for building a Delaunay graph from a Voronoi tesselation
as in the following example:</p>
<div class="highlight"><pre><span></span><span class="c1">#</span>
<span class="c1"># build Delaunay graph of neighboring (i.e. adjacent) Cc&#39;s</span>
<span class="c1">#</span>

<span class="c1"># create map label-&gt;Cc for faster lookup later</span>
<span class="n">ccs</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">cc_analysis</span><span class="p">()</span>
<span class="n">label_to_cc</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ccs</span><span class="p">:</span>
   <span class="n">label_to_cc</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>

<span class="c1"># compute area Voronoi tesselation and neighborship list</span>
<span class="n">voronoi</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">voronoi_from_labeled_image</span><span class="p">()</span>
<span class="n">labelpairs</span> <span class="o">=</span> <span class="n">voronoi</span><span class="o">.</span><span class="n">labeled_region_neighbors</span><span class="p">()</span>

<span class="c1"># build map of all neighbors for each label for fast lookup</span>
<span class="n">neighbors</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">label_to_cc</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
   <span class="n">neighbors</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">labelpairs</span><span class="p">:</span>
   <span class="n">neighbors</span><span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
   <span class="n">neighbors</span><span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="c1"># now, all neighbors to a given cc can be looked up with</span>
<span class="n">neighbors_of_cc</span> <span class="o">=</span> <span class="p">[</span><span class="n">label_to_cc</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">[</span><span class="n">cc</span><span class="o">.</span><span class="n">label</span><span class="p">]]</span>
</pre></div>
</div>
<div class="section" id="max-empty-rect">
<h1><a class="toc-backref" href="#toc-entry-7"><tt class="docutils literal">max_empty_rect</tt></a></h1>
<p><tt class="docutils literal">Rect</tt> <strong>max_empty_rect</strong> ()</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Operates on:</th><td class="field-body"><tt class="docutils literal">Image</tt> [OneBit]</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal">Rect</tt></td>
</tr>
<tr class="field"><th class="field-name">Category:</th><td class="field-body">Geometry</td>
</tr>
<tr class="field"><th class="field-name">Defined in:</th><td class="field-body">geometry.py</td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Daveed Vandevoorde and Christoph Dalitz</td>
</tr>
</tbody>
</table>
<p>Returns the maximum area empty rect that fits into the image without
containing any of the black image pixels. This problem is in the literature
generally known as the <em>Largest Empty Rectangle Problem</em>.</p>
<p>When the image does not contain a white pixel at all, an exception of type
<tt class="docutils literal">RuntimeError</tt> is thrown. The coordinates of the returned rectangle are
relative to the upper left corner of the image.</p>
<p>Reference: D. Vandevoorde: <a class="reference external" href="http://www.drdobbs.com/database/184410529">&quot;The Maximal Rectangle Problem.&quot;</a> Dr. Dobb's,
April 1998.</p>
<hr class="docutils" />
<p><strong>Example 1:</strong> max_empty_rect</p>
<p><img alt="max_empty_rect_plugin_00_00" src="images/max_empty_rect_plugin_00_00.png" style="width: 90px; height: 90px;" /></p>
</div>
<div class="section" id="voronoi-from-labeled-image">
<h1><a class="toc-backref" href="#toc-entry-8"><tt class="docutils literal">voronoi_from_labeled_image</tt></a></h1>
<p><tt class="docutils literal">Image</tt> [OneBit|GreyScale] <strong>voronoi_from_labeled_image</strong> ()</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Operates on:</th><td class="field-body"><tt class="docutils literal">Image</tt> [OneBit|GreyScale]</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal">Image</tt> [OneBit|GreyScale]</td>
</tr>
<tr class="field"><th class="field-name">Category:</th><td class="field-body">Geometry</td>
</tr>
<tr class="field"><th class="field-name">Defined in:</th><td class="field-body">geometry.py</td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Christoph Dalitz, based on code by Ullrich Köthe</td>
</tr>
</tbody>
</table>
<p>Computes the area Voronoi tesselation from an image containing labeled
Cc's. In the returned onebit image, every pixel is labeled with the
label value of the closest Cc in the input image.</p>
<p>To prepare the input image, you can use <a class="reference external" href="segmentation.html#cc-analysis">cc_analysis</a>. When the Cc's
only consist of single points, the area Voronoi tesselation is identical
to the ordinary Voronoi tesselation.</p>
<p>The implementation applies a watershed algorithm to the distance transform
of the input image, a method known as <em>seeded region growing</em> (U. Köthe:
<em>Primary Image Segmentation.</em> Proceedings 17th DAGM-Symposium, pp. 554-561,
Springer, 1995).</p>
<p>The example shown below is the image <em>voronoi_cells</em> as created with
the following code:</p>
<div class="highlight"><pre><span></span><span class="c1"># create an area Voronoi tesselation and</span>
<span class="c1"># mark the cells and their edges in color</span>
<span class="n">ccs</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">cc_analysis</span><span class="p">()</span>  <span class="c1"># labels the image</span>
<span class="n">voronoi</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">voronoi_from_labeled_image</span><span class="p">()</span>
<span class="n">voronoi_cells</span> <span class="o">=</span> <span class="n">voronoi</span><span class="o">.</span><span class="n">color_ccs</span><span class="p">()</span>
<span class="n">voronoi_cells</span><span class="o">.</span><span class="n">highlight</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">RGBPixel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="n">voronoi_edges</span> <span class="o">=</span> <span class="n">voronoi</span><span class="o">.</span><span class="n">labeled_region_edges</span><span class="p">()</span>
<span class="n">voronoi_cells</span><span class="o">.</span><span class="n">highlight</span><span class="p">(</span><span class="n">voronoi_edges</span><span class="p">,</span> <span class="n">RGBPixel</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">))</span>
</pre></div>
<hr class="docutils" />
<p><strong>Example 1:</strong> voronoi_from_labeled_image</p>
<p><img alt="voronoi_from_labeled_image_plugin_00_00" src="images/voronoi_from_labeled_image_plugin_00_00.png" style="width: 69px; height: 99px;" /> <img alt="voronoi_from_labeled_image_plugin_00_01" src="images/voronoi_from_labeled_image_plugin_00_01.png" style="width: 69px; height: 99px;" /></p>
</div>
<div class="section" id="voronoi-from-points">
<h1><a class="toc-backref" href="#toc-entry-9"><tt class="docutils literal">voronoi_from_points</tt></a></h1>
<p><strong>voronoi_from_points</strong> ([object <em>points</em>], <tt class="docutils literal">IntVector</tt> <em>labels</em>)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Operates on:</th><td class="field-body"><tt class="docutils literal">Image</tt> [OneBit|GreyScale]</td>
</tr>
<tr class="field"><th class="field-name">Category:</th><td class="field-body">Geometry</td>
</tr>
<tr class="field"><th class="field-name">Defined in:</th><td class="field-body">geometry.py</td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Christoph Dalitz</td>
</tr>
</tbody>
</table>
<p>Computes the Voronoi tesselation from a list of points and point labels.
The result is directly written to the input image. Each white pixel is
labeled with the label value of the closest point. Non white pixel in the
input image are not overwritten.</p>
<p>The arguments <em>points</em> and <em>labels</em> specify the points and labels, such
that <tt class="docutils literal">labels[i]</tt> is the label of <tt class="docutils literal">points[i]</tt>. Note that the labels
need not necessarily all be different, which can be useful as an
approximation of an area Voronoi tesselation.</p>
<p>The algorithm is very simple: it stores the points in a <a class="reference external" href="kdtree.html">kd-tree</a> and
then looks up the closest point for each image pixel. This has a runtime
of <em>O(N log(n))</em>, where <em>N</em> is the number of image pixels and <em>n</em> is the
number of points. For not too many points, this should be faster than the
morphological region growing approach of <a class="reference external" href="#voronoi-from-labeled-image">voronoi_from_labeled_image</a>.</p>
<p>The example shown below is the image <em>voronoi_edges</em> as created with
the following code:</p>
<div class="highlight"><pre><span></span><span class="c1"># create a Voronoi tesselation and mark</span>
<span class="c1"># the cell edges in a second image</span>
<span class="n">points</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">),(</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">),(</span><span class="mi">32</span><span class="p">,</span><span class="mi">22</span><span class="p">),(</span><span class="mi">85</span><span class="p">,</span><span class="mi">14</span><span class="p">),(</span><span class="mi">40</span><span class="p">,</span><span class="mi">70</span><span class="p">),(</span><span class="mi">80</span><span class="p">,</span><span class="mi">85</span><span class="p">)]</span>
<span class="n">voronoi</span> <span class="o">=</span> <span class="n">Image</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">90</span><span class="p">,</span><span class="mi">90</span><span class="p">))</span>
<span class="n">voronoi</span><span class="o">.</span><span class="n">voronoi_from_points</span><span class="p">(</span><span class="n">points</span><span class="p">,[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">))])</span>
<span class="n">voronoi_edges</span> <span class="o">=</span> <span class="n">voronoi</span><span class="o">.</span><span class="n">labeled_region_edges</span><span class="p">()</span>
<span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
   <span class="n">voronoi_edges</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
<hr class="docutils" />
<p><strong>Example 1:</strong> voronoi_from_points</p>
<p><img alt="voronoi_from_points_plugin_00_00" src="images/voronoi_from_points_plugin_00_00.png" style="width: 90px; height: 90px;" /></p>
</div>
</div>
<div class="footer">
<hr class="footer" />
<span class="raw-html"><div style="text-align:right;">For contact information, see <a href="http://gamera.informatik.hsnr.de/contact.html">http://gamera.informatik.hsnr.de/contact.html</a></div></span>
</div>
</body>
</html>
